%% tikz-nfold.sty
%% Copyright 2023 Jonathan Schulz
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3c
% of this license or (at your option) any later version.
% The latest version of this license is in
% http://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX
% version 2008-05-04 or later.
%
% This work has the LPPL maintenance status 'maintained'.
%
% The Current Maintainer of this work is Jonathan Schulz.
%
% This work consists of the files pgflibrarybezieroffset.code.tex,
% tikzlibrarynfold.code.tex, tikz-nfold-doc.tex, and tikz-nfold-doc.pdf.

%\usetikzlibrary{decorations}
\usetikzlibrary{arrows.meta}
\usepgflibrary{bezieroffset}

%%%%%%%%
% TODO %
%%%%%%%%
%
% Near future
% -----------
% - various inline TODOs in this file
% - globally rename \pgf@shiftdec@amount
% - globally rename \pgf@decoration@nfold@hwidth
% - can we remove some or all of \global, \gdef, \xdef now?
% - Fix extension into arrow tip, detect Implies
%   - try conditional logic with \pgf@end@tip@sequence? Old arrow detection code?
% - Make sure we don't break \pgf@up@draw@arrows@only
% - new code: search for "deco" to see if we missed anything
%
%
% Later
% -----
% - add "\else" in various places (likely better performance)
% - consider turning this into a pgf library, as it does not need TikZ
%   - only define /tikz/nfold in the skeleton tikz library
% - pull request to TikZ/pgf to simplify code injection
% - Do the subdivision of Bezier curves while parsing the soft path -> saves a lot of redundant calls
% - benchmark: Compare
%   - decorations approach
%   - new approach
%   - /tikz/double (i.e. not doing anything)
%   - Also: do the testing with nfold auto-set to 2 for a more realistic comparison with /tikz/double
% - fix closepath
% - update documentation
% - branch + pull request
% - Adapt the width of the bar in e.g. [arrows=|-Implies]



%
% Intercepting join settings
% --------------------------
%
% The current settings of the line joins are not stored in any TeX registers; instead, direct system
% calls are made to apply the settings. Therefore, we need to modify the pgf macros in order
% to cache the current settings.
%

% According to the pgf documentation, miter limit=10 is the default value,
% but I couldn't find and verify this setting in the pgf code
\gdef\pgf@nfold@cached@miterlimit{10}
\let\pgf@nfold@old@miterlimit\pgfsetmiterlimit
\def\pgfsetmiterlimit#1{%
  \pgf@nfold@old@miterlimit{#1}%
  \edef\pgf@nfold@cached@miterlimit{#1}%
}

% default line join is "miter"
\global\let\pgf@cached@linejoin=m% % b = bevel, m=miter, r=round
\let\pgf@nfold@old@setbeveljoin\pgfsetbeveljoin
\let\pgf@nfold@old@setmiterjoin\pgfsetmiterjoin
\let\pgf@nfold@old@setroundjoin\pgfsetroundjoin
\def\pgfsetbeveljoin{%
  \pgf@nfold@old@setbeveljoin%
  % do NOT change this globally! Needs to be changed back at the end of groups for scoping reasons
  \let\pgf@cached@linejoin=b%
}
\def\pgfsetmiterjoin{%
  \pgf@nfold@old@setmiterjoin%
  \let\pgf@cached@linejoin=m%
}
\def\pgfsetroundjoin{%
  \pgf@nfold@old@setroundjoin%
  \let\pgf@cached@linejoin=r%
}

%
% Various helper commands
% -----------------------

% check if a segment is visible, i.e. not moveto or last
% TODO add else's + error if not in the list
\newif\ifpgf@nfold@segm@visible
\def\checkpgfsegmentvisible#1{%
  \pgf@nfold@segm@visiblefalse%
  \ifx#1\pgf@nfold@inputsegmentlineto%
  \pgf@nfold@segm@visibletrue\fi%
  \ifx#1\pgf@nfold@inputsegmentcurveto%
  \pgf@nfold@segm@visibletrue\fi%
  \ifx#1\pgf@nfold@inputsegmentclosepath%
  \pgf@nfold@segm@visibletrue\fi%
}


%
% Joining offset lines
% --------------------
%
% One of the more difficult aspects is joining the segments of an offset path. Without this step,
% the path would be interrupted or self-intersect whenever there is a non-zero angle between
% two segments. This code reproduces the existing line joins "bevel", "miter" and "round".
%

\def\pgf@nfold@miterjoin{
  % The tip of the miter join is computed starting from the original (unshifted) centre of the join;
  % we then move orthorgonal to the average of the old and new angle
  \pgfpointadd%
    {\pgf@nfold@inputsegment@first}%
    {\pgfpointpolar%
      {\pgf@nfold@previous@endangle+.5*\pgf@nfold@deltaphi+90}% do not change
      {\pgf@shiftdec@amount/cos(.5*\pgf@nfold@deltaphi)}%
    }%
  \pgfpathlineto{}%
}

\def\pgf@nfold@beveljoin{
  % The bevel join for one component line consists of three parts:
  % 1) an extension of the ingoing line,
  % 2) a middle line, angled at the average of the incoming and outgoing line,
  % 3) an extension of the outgoing line.
  % Different components of the ingoing and outgoing lines have a constant distance from each other.
  % For a good-looking output, the mittle parts of the component lines thus should also have a constant distance,
  % which is a non-trivial condition. To generate such an output the outer lines get a bevel-like join
  % and the inner lines get a miter-like join; the threshold depends on deltaphi.
  % We first compute by how much the outermost line must be continued from the beginning of the join.
  % The protrusion amount must be lowered by a little bit for a rather complicated reason: The offset would be
  % dead on if the outermost offset line were centered on the _edge_ of the wide line, but we want to draw 
  % the outside line _fully inside_ the wide line. The factor of tan(deltaphi/4) can be derived, but is not obvious.
  \pgfmathsetlengthmacro{\bevelouterprotrusion}%
    {\pgf@nfold@shortenstartjoin - .5*\pgflinewidth*abs(tan(.25*\pgf@nfold@deltaphi))}
  % The following applies to middle lines only: We compute by how much they need to be shortened so the distance
  % between the lines in the join is correct.
  \pgfmathsetmacro{\bevelshorten}{2*\insidepercentage*abs(tan(.25*\pgf@nfold@deltaphi))}
  % This threshold decides if the inside line has a bevel or a miter join
  \pgfmathparse{\bevelshorten < abs(sin(.5*\pgf@nfold@deltaphi))}
  \ifnum\pgfmathresult=1\relax
    \pgfmathsetlengthmacro{\bevelextension}{\bevelouterprotrusion-\bevelshorten*\pgf@decoration@nfold@hwidth}
    \pgfpointadd{\pgf@nfold@join@start}{\pgfpointpolar{\pgf@nfold@previous@endangle}{\bevelextension}}
    \pgfpathlineto{}
    \pgfpointadd{\pgf@nfold@join@end}{\pgfpointpolar{\pgf@nfold@cur@startangle}{-\bevelextension}}
    \pgfpathlineto{}
  \else
    \pgf@nfold@miterjoin
  \fi
}

\def\pgf@nfold@roundjoin{
  % The outer half of the lines get arcs, the others get miters
  \ifdim\insidepercentage pt<.5pt\relax
    \pgfpointadd{\pgf@nfold@join@start}{\pgfpointpolar{\pgf@nfold@previous@endangle}{\pgf@nfold@shortenstartjoin}}
    \pgfpathlineto{}
    % Check if the angles are in the correct range; under some conditions we must add or subtract 360
    \pgfmathparse{\turnindicator*(\pgf@nfold@cur@startangle-\pgf@nfold@previous@endangle)}
    \ifdim\pgfmathresult pt>0pt\relax
      \pgfmathsetmacro{\targetang}{\pgf@nfold@cur@startangle-\turnindicator*360}
    \else
      \let\targetang\pgf@nfold@cur@startangle
    \fi
    \pgfpatharc%
      {\pgf@nfold@previous@endangle+90*\turnindicator}%
      {\targetang+90*\turnindicator}%
      {abs(\pgf@shiftdec@fraction)*\pgf@decoration@nfold@hwidth}%
  \else
    \pgf@nfold@miterjoin
  \fi
}

\def\pgf@nfold@make@join{
  % Offset the start and end of this join
  \pgfpointadd{\pgf@nfold@cached@endpoint}{\pgfpointpolar{\pgf@nfold@previous@endangle+90}{\pgf@shiftdec@amount}}
  \pgfstorepoint\pgf@nfold@join@start
  \pgfpointadd{\pgf@nfold@segment@start}{\pgfpointpolar{\pgf@nfold@cur@startangle+90}{\pgf@shiftdec@amount}}
  \pgfstorepoint\pgf@nfold@join@end
  \pgfpointdiff{\pgf@nfold@join@start}{\pgf@nfold@join@end}
  % Check if the start of this segment is too close to the end of the previous segment.
  % In that case we don't insert a join segment, as it would look rather glitchy.
  % We use the Manhattan length for performance and to avoid 'dimension too large' errors.
  \pgfmathparse{abs(\pgf@x) + abs(\pgf@y)}
  \ifdim\pgfmathresult pt>0.1pt\relax
    % First step: Check if left or right turn (-1 = left, 1=right)
    % TODO can we refactor this to just the sign of deltaphi?
    \pgfmathsetmacro{\turnindicator}{sign(sin(-\pgf@nfold@deltaphi)}
    % between 0.0 and 1.0; 0=no distance to cover in the join, 1=maximum distance to cover
    \pgfmathsetmacro{\insidepercentage}{-.5*\turnindicator*\pgf@shiftdec@fraction+.5}
    \if m\pgf@cached@linejoin % because both are only one character, \ifx is not needed
      % miter join
      % First we implement the miter limit: If the angle is too sharp, the miter join is replaced
      % by a bevel join. This is controlled by /tikz/miter limit=..., initially 10.
      \pgfmathsetmacro{\mitercosine}{abs(cos(.5*\pgf@nfold@deltaphi))}
      \pgfmathparse{\mitercosine*\pgf@nfold@cached@miterlimit}
      \ifdim\pgfmathresult pt>1pt\relax
        \pgf@nfold@miterjoin
      \else
        \pgf@nfold@beveljoin
      \fi
    \else
      \if b\pgf@cached@linejoin\relax
        \pgf@nfold@beveljoin
      \else
        \if r\pgf@cached@linejoin
          % round join
          \pgf@nfold@roundjoin
        \fi
      \fi
    \fi
    % All non-trivial joins connect to the end of the join, which is the starting point of the current segment.
    % Note that this entire macro is skipped by if the start and end of the join coincide, so we never create a zero length segment here.
    %
    % There is one edge case here: If two subsequent joins are so close that \pgf@nfold@segment@end
    % and \pgf@nfold@segment@start exchange places *and* we are on the outside of the join 
    % (implying that we are on the inside of the next join), \pgf@nfold@join@end will be located behind the next join.
    % In this case we instead connect to the offset of \pgf@nfold@segment@end (which comes *before* \pgf@nfold@segment@start).
    \pgf@nfold@join@end% default point to connect to
    \ifpgf@nfold@closejoinsedgecase%
      \ifdim\insidepercentage pt<.5pt\relax%
        \pgfpointadd{\pgf@nfold@segment@end}%
        {\pgfpointpolar{\pgf@nfold@cur@startangle+90}{\pgf@shiftdec@amount}}
      \fi%
    \fi
    \pgfpathlineto{}
  \fi
}


%
% Main rendering pipeline
% -----------------------
%

% This stores whether the current segment should begin with a moveto to its offset
\newif\ifpgf@nfold@continuesegment
% This stores whether we are in some edge case of very close joins, see below for details
\newif\ifpgf@nfold@closejoinsedgecase
% This stores whether we are in an error case where we need to avoid dividing by zero
\newif\ifpgf@nfold@angletoosharp



% TODO rename
\def\pgf@nfold@handlesegment@testoffset{%
  %%% Step 0: Preparation
  % Set some default values; they might get overwritten later
  \let\pgf@nfold@segment@start\pgf@nfold@inputsegment@first
  \let\pgf@nfold@segment@end\pgf@nfold@inputsegment@last
  % Set a default value for \ifpgf@nfold@continuesegment.
  % It may be overwritten by \pgf@nfold@extendtotip
  \ifx\pgf@nfold@previousinputsegment\pgf@nfold@inputsegmentmoveto
    \pgf@nfold@continuesegmentfalse
  \else
    \pgf@nfold@continuesegmenttrue
  \fi
  %%% Step 1: Make space for joins if necessary
  % In order to make space for the join, it may be necessary to shorten the current segment
  % at the start and/or the end. In here we store by how much the segment needs to be shortened.
  \def\pgf@nfold@shortenstartjoin{0pt}
  \def\pgf@nfold@shortenendjoin{0pt}
  \pgf@nfold@closejoinsedgecasefalse
  \pgf@nfold@angletoosharpfalse
  % Make a join only if two adjacent segments are both visible
  \checkpgfsegmentvisible\pgf@nfold@currentinputsegment
  \ifpgf@nfold@segm@visible%
    % Step 1.1: Make space for the join at the start if needed
    \ifx\pgf@nfold@previousinputsegment\pgf@nfold@inputsegmentmoveto\else
      % TODO Future idea: Also check if we move backwards further than the length of the line plus one (or two) hwidth's
      \pgfmathparse{abs(\pgf@nfold@deltaphi@start) > 178}
      \ifnum\pgfmathresult=1\relax
        % we go full backwards, don't relocate the start and disable the join to avoid division by zero
        \pgfwarning{Angle too sharp in 'nfold', expect visual errors}
        \pgf@nfold@angletoosharptrue
      \else
        \pgfmathsetlengthmacro{\pgf@nfold@shortenstartjoin}%
          {\pgf@decoration@nfold@hwidth*abs(tan(0.5*\pgf@nfold@deltaphi@start))}
        \pgfpointadd{\pgf@nfold@inputsegment@first}%
          {\pgfpointpolar{\pgf@nfold@cur@startangle}{\pgf@nfold@shortenstartjoin}}
        \pgfstorepoint\pgf@nfold@segment@start
      \fi
    \fi
    % Step 1.2: Make space for the join at the end if needed
    \checkpgfsegmentvisible\pgf@nfold@next@segmenttype
    \ifpgf@nfold@segm@visible%
      \pgfmathparse{abs(\pgf@nfold@deltaphi@end) > 178}
      \ifnum\pgfmathresult=1\relax
        % we go full backwards, don't relocate the start
        \pgfwarning{Angle too sharp in 'nfold', expect visual errors}
      \else
        \pgfmathsetlengthmacro{\pgf@nfold@shortenendjoin}%
          {\pgf@decoration@nfold@hwidth*abs(tan(0.5*\pgf@nfold@deltaphi@end))}
        \pgfpointadd{\pgf@nfold@inputsegment@last}%
          {\pgfpointpolar{\pgf@nfold@cur@endangle}{-\pgf@nfold@shortenendjoin}}
        \pgfstorepoint\pgf@nfold@segment@end
      \fi
      % Step 1.3: Detect an edge case
      % This edge case appears whenever the current segment is such a short line that we would
      % have to reduce its length to less than zero to make space for the joins. In such cases,
      % the line is not drawn at all, and slight modifications must be made to the joins to ensure
      % a correct output (i.e. one join is immediately followed by the next without a segment in between).
      %
      % This edge case can appear for curves as well, but they are much harder to deal with.
      \ifx\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentlineto
        % No need to check for \pgf@nfold@inputsegmentclosepath as it should not be followed by any further segments
        % Now: Check if the total amount of shortening is larger than the length of the segment
        \pgfpointdiff{\pgf@nfold@inputsegment@first}{\pgf@nfold@inputsegment@last}
        \pgfmathparse{\pgf@nfold@shortenstartjoin+\pgf@nfold@shortenendjoin > veclen(\pgf@x,\pgf@y)}
        \ifnum\pgfmathresult=1\relax
          \pgf@nfold@closejoinsedgecasetrue
        \fi
      \fi
    \fi% end if next segment visible
    %
    % Step 2: Draw the join at the start if applicable
    %
    \ifx\pgf@nfold@previousinputsegment\pgf@nfold@inputsegmentmoveto
      \ifpgf@nfold@closejoinsedgecase
        % If the previous segment is a moveto and the current segment is a "close joins" edge case,
        % nothing needs to be drawn here (the relevant draw call will be made at the join of the subsequent
        % segment). We must therefore make sure that we move to the correct end point of this segment.
        % Counterintuitively, this is given by the offset of \pgf@nfold@segment@start since the start and end
        % are reversed in the edge case.
        \pgfpointadd%
          {\pgf@nfold@segment@start}%
          {\pgfpointpolar{\pgf@nfold@cur@startangle+90}{\pgf@shiftdec@amount}}
        \pgfpathmoveto{}
       \fi
    \else
      % TODO pass the angle as a parameter instead?
      % If we draw the lines when the start angle is close to 180 degrees, we get a division by zero 
	  \ifpgf@nfold@angletoosharp\else
        \let\pgf@nfold@deltaphi\pgf@nfold@deltaphi@start
        \pgf@nfold@make@join
      \fi
    \fi
  \fi% end if current segment visible
  %
  % Step 3: Draw the new segment.
  %
  % The value of \ifpgf@nfold@continuesegment decides whether we start with a moveto.
  % TODO should closepath and moveto also be excluded from the edge case?
  % The edge case can only happen for lineto; it would still be cleaner to switch this around
  \ifpgf@nfold@closejoinsedgecase\else
    \ifx\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentmoveto
      \pgfpathmoveto{\pgf@nfold@inputsegment@last}
    \fi
    \ifx\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentlineto
      \ifpgf@nfold@continuesegment
        \pgfoffsetlinenomove{\pgf@nfold@segment@start}{\pgf@nfold@segment@end}{\pgf@shiftdec@amount}
      \else
        \pgfoffsetline{\pgf@nfold@segment@start}{\pgf@nfold@segment@end}{\pgf@shiftdec@amount}
      \fi
    \fi
    \ifx\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentclosepath
	  % Incomplete: proper join is missing
      % Idea: when parsing the path, add a detection if there is a closepath at the current segment,
      % then cache the data of the last segment.
      % We could then insert a "fake previous segment" into the path at the right place
      \pgfwarning{'nfold': The option 'cycle' is not yet properly supported.}
      \pgfpathclose
% TODO Old code, likely no longer needed
%      \ifpgf@nfold@continuesegment
%        \pgfoffsetlinenomove{\pgf@nfold@segment@start}{\pgf@nfold@segment@end}{\pgf@shiftdec@amount}
%      \else
%        \pgfoffsetline{\pgf@nfold@segment@start}{\pgf@nfold@segment@end}{\pgf@shiftdec@amount}
%      \fi
    \fi
    \ifx\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentcurveto
      \ifpgf@nfold@continuesegment
        \pgfoffsetcurvenomove{\pgf@nfold@segment@start}{\pgf@nfold@inputsegment@supporta}{\pgf@nfold@inputsegment@supportb}{\pgf@nfold@segment@end}{\pgf@shiftdec@amount}
      \else
        \pgfoffsetcurve{\pgf@nfold@segment@start}{\pgf@nfold@inputsegment@supporta}{\pgf@nfold@inputsegment@supportb}{\pgf@nfold@segment@end}{\pgf@shiftdec@amount}
      \fi
    \fi
  \fi% end if edge case
  % cache the end point because we need it on the next pass
  \ifx\pgf@nfold@next@inputsegment\pgf@nfold@inputsegmentmoveto\else
    \global\let\pgf@nfold@cached@endpoint\pgf@nfold@segment@end
  \fi
  % TODO needs to be re-implemented
  % Step 4: Extend into the arrow tip at the end (if present)
%  \ifx\pgfdecorationnextinputsegmentobject\pgf@nfold@inputsegmentlast%
%    \pgf@nfold@check@tip@end%
%    \ifpgf@nfold@tip@implies%
%      \pgf@nfold@extendtotip{e}%
%    \fi%
%  \fi%
}



%
% Hooking into pgf's rendering pipeline
% -------------------------------------
%
% The new code has to be injected into \pgfusepath (pgfcorepathusage.code.tex). For rendering the new paths,
% \pgf@stroke@inner@line is a natural choice as this is where /tikz/double is rendered. However, we also
% need to disable rendering the ordinary path, which is not as easy. In the future I will make a pull request
% to TikZ to simplify such injections.
%
% The call to draw the path comes right before \pgf@stroke@inner@line. The macro before \pgf@stroke@inner@line
% is either \pgf@path@check@proper or \pgf@prepare@start@of@path (depending on the result of the proper check).
% We therefore must inject code into both of them to see if nfold is enabled. If it is, we call the old macro,
% cache and delete the current softpath (so the call to \pgfsyssoftpath@invokecurrentpath has no effect), then we
% restore and offset the cached softpath in \pgf@stroke@inner@line.
%
% TODO: The only other places where \pgf@path@check@proper and \pgf@prepare@start@of@path show up is in
% \pgf@up@draw@arrows@only; we must make sure that this call remains unmodified. Further changes are likely necessary.
%

\newcount\pgf@nfold@order
\pgf@nfold@order=0

\def\pgf@nfold@preparenfoldpath{%
  \ifnum\pgf@nfold@order>1\relax
    \ifdim\pgfinnerlinewidth>0pt\relax
      % Hack the rendering pipeline: There is a \pgfsyssoftpath@invokecurrentpath call following
      % which we do not want if nfold is active. We therefore clear the current path here
      % and then perform the nfold drawing in our modification of \pgf@stroke@inner@line
      \pgfsyssoftpath@getcurrentpath\cachedpath%
      \pgfsyssoftpath@setcurrentpath\pgfutil@empty%
    \else
      \pgferror{TODO: This is probably the error "must enable /tikz/double to use nfold"; can this occur under different circumstances?}
    \fi
  \fi
}

\let\pgf@nfold@old@path@check@proper\pgf@path@check@proper
\def\pgf@path@check@proper{%
  \pgf@nfold@old@path@check@proper%
  \ifpgfutil@tempswa\else
    % if \pgfutil@tempswa is false, this is the last macro we can overwrite before the draw call.
    % Otherwise, we inject into \pgf@prepare@start@of@path%
    \pgf@nfold@preparenfoldpath%
  \fi%
}

\let\pgf@nfold@old@prepare@start@of@path\pgf@prepare@start@of@path
\def\pgf@prepare@start@of@path{%
  \pgf@nfold@old@prepare@start@of@path%
  \pgf@nfold@preparenfoldpath%
}

\let\pgf@nfold@old@stroke@inner@line\pgf@stroke@inner@line
\def\pgf@stroke@inner@line{%
  \ifnum\pgf@nfold@order>1\relax%
    \pgf@nfold@render@cached@softpath%
  \else%
    % Old behaviour
    \pgf@nfold@old@stroke@inner@line%
  \fi%
}


%
% Parsing the soft path
% ---------------------
%
% A significant part of the code below is based on pgfmoduledecorations.code.tex (c) 2019 Mark Wibrow and Till Tantau.
% Quite similar to decorations we parse the current soft path and put it into a form that makes it easier
% to iterate over.
%
%

\def\pgf@nfold@parsesoftpath#1#2{%
  \def\pgf@nfold@inputsegmentobjectsmacro{#2}%
  \let\pgf@nfold@inputsegmentobjects\pgfutil@empty%
  \pgfutil@tempdima0pt\relax%
  \let\pgfpoint@nfold@lastparsed\pgfpoint@nfold@existingpathlast%
  \let\pgfpoint@nfold@lastnonmovetoparsed\pgfpoint@origin%
  \let\pgf@nfold@queueinputsegmentobject\pgfutil@empty%
  \let\pgfpoint@nfoldd@firstparsed\pgfutil@empty%
  \expandafter\pgf@nfold@@parsesoftpath#1\pgf@stop%
}%

\def\pgf@nfold@@parsesoftpath#1{%
  \ifx#1\pgf@stop%
    \let\pgf@nfold@queueinputsegmentobject\pgfutil@empty% <- removes final moveto (may not be desirable).
    \pgf@nfold@addtoinputsegmentobjects{\pgf@nfold@inputsegmentobject@endofinputsegments}%
		% probably so that the last segment also has a well-defined next segment
    \pgf@nfold@addtoinputsegmentobjects{\pgf@nfold@inputsegmentobject@endofinputsegments}%
    \expandafter\let\pgf@nfold@inputsegmentobjectsmacro\pgf@nfold@inputsegmentobjects%
    \let\pgf@next\relax%
  \else%
    \ifx#1\pgfsyssoftpath@movetotoken%
      \let\pgf@next\pgf@nfold@parsemoveto%
    \else%
      \ifx#1\pgfsyssoftpath@linetotoken%
        \let\pgf@next\pgf@nfold@parselineto%
      \else%
        \ifx#1\pgfsyssoftpath@curvetosupportatoken%
          \let\pgf@next\pgf@nfold@parsecurveto%
        \else%
          \ifx#1\pgfsyssoftpath@closepathtoken%
            \let\pgf@next\pgf@nfold@parseclosepath%
% TODO test and implement rect's
%          \else%
%            \ifx#1\pgfsyssoftpath@rectcornertoken%
%              \let\pgf@next\pgf@nfold@parserect%
%            \else%
%              \pgferror{Unrecognised soft path token `#1'}%
%            \fi%
          \fi%
        \fi%
      \fi%
    \fi%
  \fi%
  \pgf@next}%


\def\pgf@nfold@parsemoveto#1#2{%
  \def\pgf@nfold@queueinputsegmentobject{\pgf@nfold@inputsegmentobject@moveto{\pgf@x#1\pgf@y#2}}%
  \def\pgfpoint@nfold@lastparsed{\pgf@x#1\pgf@y#2}%
  \pgf@nfold@@parsesoftpath%
}%

% Convert \pgfsyssoftpath@linetotoken{<X>}{<Y>} into the following
% representation:
%
% \pgf@nfold@inputsegmentobject@lineto{<length>}{\pgf@x <Last X> \pgf@y <Last Y>}{\pgf@x <X> \pgf@y <Y>}
%
\def\pgf@nfold@parselineto#1#2{%
  \edef\pgf@nfold@temp{%
    \noexpand\pgf@nfold@inputsegmentobject@lineto{0 pt}{\pgfpoint@nfold@lastparsed}{\pgf@x#1\pgf@y#2}%
  }%
  \edef\pgfpoint@nfold@lastparsed{\pgf@x#1\pgf@y#2}%
  \let\pgfpoint@nfold@lastnonmovetoparsed\pgfpoint@nfold@lastparsed%
  \expandafter\pgf@nfold@addtoinputsegmentobjects\expandafter{\pgf@nfold@temp}%
  \pgf@nfold@@parsesoftpath%
}%

\def\pgf@nfold@parsecurveto#1#2\pgfsyssoftpath@curvetosupportbtoken#3#4\pgfsyssoftpath@curvetotoken#5#6{%
%  \pgf@decorate@curvelength{\pgfpoint@decorate@lastparsed}{\pgf@x#1\pgf@y#2}{\pgf@x#3\pgf@y#4}{\pgf@x#5\pgf@y#6}%
%  \advance\pgfutil@tempdima\pgfmathresult pt\relax%
  \edef\pgf@nfold@temp{%
    \noexpand\pgf@nfold@inputsegmentobject@curveto{0 pt}{\pgfpoint@nfold@lastparsed}%
      {\pgf@x#1\pgf@y#2}{\pgf@x#3\pgf@y#4}{\pgf@x#5\pgf@y#6}%
  }%
  \expandafter\pgf@nfold@addtoinputsegmentobjects\expandafter{\pgf@nfold@temp}%
  \edef\pgfpoint@nfold@lastparsed{\pgf@x#5\pgf@y#6}%
  \let\pgfpoint@nfold@lastnonmovetoparsed\pgfpoint@nfold@lastparsed%
  \pgf@nfold@@parsesoftpath%
}%

\def\pgf@nfold@parseclosepath#1#2{%
  \edef\pgf@nfold@temp{%
    \noexpand\pgf@nfold@inputsegmentobject@closepath{0 pt}{\pgfpoint@nfold@lastparsed}{\pgf@x#1\pgf@y#2}%
  }%
  \let\pgfpoint@nfold@lastnonmovetoparsed\pgfpoint@nfold@lastparsed%
  \expandafter\pgf@nfold@addtoinputsegmentobjects\expandafter{\pgf@nfold@temp}%
  \pgf@nfold@@parsesoftpath%
}%

\def\pgf@nfold@addtoinputsegmentobjects#1{%
  %
  % If there is an input segment object waiting (i.e. a moveto), insert it here.
  %
  \ifx\pgf@nfold@queueinputsegmentobject\pgfutil@empty%
  \else%
    \let\pgf@nfold@temp\pgf@nfold@queueinputsegmentobject%
    \let\pgf@nfold@queueinputsegmentobject\pgfutil@empty%
    \expandafter\pgf@nfold@addtoinputsegmentobjects\expandafter{\pgf@nfold@temp}%
  \fi%
  \ifx\pgfpoint@nfold@firstparsed\pgfutil@empty%
    #1%
    \let\pgfpoint@nfold@firstparsed\pgf@nfold@inputsegment@first%
  \fi%
  \expandafter\def\expandafter\pgf@nfold@inputsegmentobjects\expandafter%
    {\pgf@nfold@inputsegmentobjects{#1}}%
}%




%% Components of the path, modified
\def\pgf@nfold@inputsegmentmoveto{moveto}%
\def\pgf@nfold@inputsegmentlineto{lineto}%
\def\pgf@nfold@inputsegmentcurveto{curveto}%
\def\pgf@nfold@inputsegmentclosepath{closepath}%
\def\pgf@nfold@inputsegmentlast{last}%


\def\pgf@nfold@inputsegmentobject@moveto#1{%
  \def\pgf@nfold@inputsegment@first{#1}%
  \def\pgf@nfold@inputsegment@supporta{#1}%
  \def\pgf@nfold@inputsegment@supportb{#1}%
  \def\pgf@nfold@inputsegment@last{#1}%
  \edef\pgf@nfold@lastmoveto{#1}%
  \let\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentmoveto%
}%


% TODO remove the #1 length parameter from all of these (and also above)

\def\pgf@nfold@inputsegmentobject@lineto#1#2#3{%
  \def\pgf@nfold@inputsegment@first{#2}%
  \def\pgf@nfold@inputsegment@last{#3}%
  \let\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentlineto%
}%

\def\pgf@nfold@inputsegmentobject@curveto#1#2#3#4#5{%
  \def\pgf@nfold@inputsegment@first{#2}%
  \def\pgf@nfold@inputsegment@supporta{#3}%
  \def\pgf@nfold@inputsegment@supportb{#4}%
  \def\pgf@nfold@inputsegment@last{#5}%
  \let\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentcurveto%
}%

\def\pgf@nfold@inputsegmentobject@closepath#1#2#3{%
  \def\pgf@nfold@inputsegment@first{#2}%
  \def\pgf@nfold@inputsegment@last{#3}%
  \let\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentclosepath%
}%

\def\pgf@nfold@inputsegmentobject@endofinputsegments{%
  \let\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentlast%
}%


\def\pgf@nfold@traversepath{%
  % Transformations are already baked into the path; without this call, they will be applied twice
  \pgftransformreset
  % could likely also use \let\pgf@nfold@currentinputsegmentobjects\parsedsoftpath here
  \let\pgf@nfold@currentinputsegmentobjects\pgf@nfold@inputsegmentobjects%
%  \let\pgf@nfold@transformtoinputsegment\pgfutil@empty% we may need this one for closepath
  \pgf@nfold@getnextinputsegmentobject\pgf@nfold@nextinputsegmentobject%
  \def\pgf@nfold@cur@endangle{0.0} % put in some default value so \pgf@nfold@previous@endangle is not undefined
  \pgf@nfold@traversepath@
}


\def\pgf@nfold@traversepath@{
  \pgf@nfold@processnextinputsegmentobject%
  \ifx\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentlast\else
    \pgf@nfold@handlesegmentmacro%
  \fi%
  \ifx\pgf@nfold@currentinputsegmentobjects\pgfutil@empty%
    \let\pgf@next\relax%
  \else%
    \let\pgf@next\pgf@nfold@traversepath@%
  \fi%
  \pgf@next%
}


\def\pgf@nfold@computeangles{
  % TODO add the improved code for partially singular curves here
  \ifx\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentcurveto%
    \pgfmathanglebetweenpoints{\pgf@nfold@inputsegment@first}{\pgf@nfold@inputsegment@supporta}%
    \edef\pgf@nfold@cur@startangle{\pgfmathresult}
    \pgfmathanglebetweenpoints{\pgf@nfold@inputsegment@supportb}{\pgf@nfold@inputsegment@last}%
    \edef\pgf@nfold@cur@endangle{\pgfmathresult}
  \else%
    \pgfmathanglebetweenpoints{\pgf@nfold@inputsegment@first}{\pgf@nfold@inputsegment@last}%
    \edef\pgf@nfold@cur@startangle{\pgfmathresult}
    \edef\pgf@nfold@cur@endangle{\pgfmathresult}
  \fi%
}

\def\pgf@nfold@clampangle{
  % The computed angles are values between 0 and 360, so their difference is between 360 and -360;
  % we want the difference to be between -180 and 180
  % This can also be done using one \pgfmathparse and Mod, but this is more efficient
	% TODO drop \pgfmathparse
  \ifdim\pgfmathresult pt<-180pt\relax
    \pgfmathparse{\pgfmathresult+360}
  \else\ifdim\pgfmathresult pt>180pt\relax
    \pgfmathparse{\pgfmathresult-360}
  \fi\fi
}

\def\pgf@nfold@getnextinputsegmentobject#1{%
  \ifx\pgf@nfold@currentinputsegmentobjects\pgfutil@empty%
    \let\pgf@next\relax%
  \else%
    \def\pgf@nfold@temp{#1}%
    \let\pgf@next\pgf@nfold@@getnextinputsegmentobject%
  \fi%
  \pgf@next%
}%
\def\pgf@nfold@@getnextinputsegmentobject{%
  \expandafter\pgf@nfold@@@getnextinputsegmentobject\pgf@nfold@currentinputsegmentobjects\pgf@stop}%
\def\pgf@nfold@@@getnextinputsegmentobject#1#2\pgf@stop{%
  \expandafter\def\pgf@nfold@temp{#1}%
  \def\pgf@nfold@currentinputsegmentobjects{#2}}%

\def\pgf@nfold@processnextinputsegmentobject{%
  \let\pgf@nfold@previousinputsegment\pgf@nfold@currentinputsegment%
  \let\pgf@nfold@previous@endangle\pgf@nfold@cur@endangle%
  \let\pgf@nfold@currentinputsegmentobject\pgf@nfold@nextinputsegmentobject%
  \pgf@nfold@getnextinputsegmentobject\pgf@nfold@nextinputsegmentobject%
  % TODO We may be able to optimise away redundant calls here in the future
  \pgf@nfold@nextinputsegmentobject% parse the *next* input segment so we can compute its angles
  \pgf@nfold@computeangles%
  \let\pgf@nfold@next@first\pgf@nfold@inputsegment@first%
  \let\pgf@nfold@next@supporta\pgf@nfold@inputsegment@supporta%
  \let\pgf@nfold@next@supportb\pgf@nfold@inputsegment@supportb%
  \let\pgf@nfold@next@last\pgf@nfold@inputsegment@last%
  \let\pgf@nfold@next@segmenttype\pgf@nfold@currentinputsegment%
  \let\pgf@nfold@next@startangle\pgf@nfold@cur@startangle%
  \pgf@nfold@currentinputsegmentobject% get the current segment into \pgf@nfold@inputsegment@first etc.
  \pgf@nfold@computeangles%
  % Compute the angle differences at the start and end (between -180 and +180 degrees)
  \pgfmathparse{\pgf@nfold@cur@startangle-\pgf@nfold@previous@endangle}
  \pgf@nfold@clampangle
  \edef\pgf@nfold@deltaphi@start{\pgfmathresult}
  \pgfmathparse{\pgf@nfold@next@startangle-\pgf@nfold@cur@endangle}
  \pgf@nfold@clampangle
  \edef\pgf@nfold@deltaphi@end{\pgfmathresult}
}


%
% Iterating over the parsed soft path
% -----------------------------------
%


% TODO Remove test code
% Test code: Render the path without offsetting
\def\pgf@nfold@handlesegment@stock{
  \ifx\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentmoveto
    \pgfpathmoveto{\pgf@nfold@inputsegment@last}
  \fi
  \ifx\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentlineto
    \pgfpathlineto{\pgf@nfold@inputsegment@last}
  \fi
  \ifx\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentcurveto
    \pgfpathcurveto{\pgf@nfold@inputsegment@supporta}{\pgf@nfold@inputsegment@supportb}{\pgf@nfold@inputsegment@last}
  \fi
  \ifx\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentclosepath
    \pgfpathclose
  \fi
}

\newcount\pgf@nfold@index
\def\pgf@nfold@run@loop{%
  \pgf@nfold@index=\pgf@nfold@order%
  \pgf@nfold@run@loop@%
}

\def\pgf@nfold@run@loop@{%
  \pgf@nfold@loop@inner%
  \advance\pgf@nfold@index by -1\relax
  \ifnum\pgf@nfold@index>0\relax%
    \pgf@nfold@run@loop@%
  \fi%
}

\def\pgf@nfold@loop@inner{%
  \pgfmathsetmacro{\pgf@shiftdec@fraction}%
    {-1+2*(\pgf@nfold@index-1)/(\pgf@nfold@order-1)}
  \pgfmathsetlengthmacro{\pgf@shiftdec@amount}{\pgf@decoration@nfold@hwidth*\pgf@shiftdec@fraction}
  \let\pgf@nfold@handlesegmentmacro\pgf@nfold@handlesegment@testoffset
  \pgf@nfold@traversepath%
  \pgfsyssoftpath@flushcurrentpath%
  \pgf@up@action%
}

\def\pgf@nfold@render@cached@softpath{%
  \pgfscope% must use a scope, otherwise we break the arrow tips
    \pgfprocessround{\cachedpath}{\cachedpath}% remove tokens from the soft path
    \pgf@nfold@parsesoftpath{\cachedpath}{\parsedsoftpath}
    % Compute the full and constituent part line widths
    \pgfutil@tempdima=\pgflinewidth\relax%
    \pgfutil@tempdimb=\pgfutil@tempdima\relax%
    \advance\pgfutil@tempdima-\pgfinnerlinewidth\relax%
    \advance\pgfutil@tempdimb+\pgfinnerlinewidth\relax%
    \pgfutil@tempdima=.5\pgfutil@tempdima\relax%
    \pgfutil@tempdimb=.25\pgfutil@tempdimb\relax%
    \pgfsetlinewidth\pgfutil@tempdima%
    \edef\pgf@decoration@nfold@hwidth{\the\pgfutil@tempdimb}
    \pgf@nfold@run@loop
  \endpgfscope
}


%
% pgf keys / user interface
% -------------------------
%

\pgfkeys{
  /pgf/nfold/.code={%
    \pgf@nfold@order=#1\relax%
    \ifnum\pgf@nfold@order<2\relax%
      \pgferror{'nfold' must take a value of at least 2, got \the\pgf@nfold@order}%
    \fi%
  },
  /pgf/nfold/.default=2,
  /tikz/nfold/.forward to=/pgf/nfold
}

\endinput
