%% tikz-nfold.sty
%% Copyright 2023 Jonathan Schulz
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3c
% of this license or (at your option) any later version.
% The latest version of this license is in
% http://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX
% version 2008-05-04 or later.
%
% This work has the LPPL maintenance status 'maintained'.
%
% The Current Maintainer of this work is Jonathan Schulz.
%
% This work consists of the files pgflibrarybezieroffset.code.tex,
% tikzlibrarynfold.code.tex, tikz-nfold-doc.tex, and tikz-nfold-doc.pdf.

%\usetikzlibrary{decorations}
\usetikzlibrary{arrows.meta}
\usepgflibrary{bezieroffset}

%%%%%%%%
% TODO %
%%%%%%%%
%
% Near future
% -----------
% - various inline TODOs in this file
% - globally rename \pgf@shiftdec@amount
% - globally rename \pgf@decoration@nfold@hwidth
% - can we remove some or all of \global, \gdef, \xdef now?
% - Make sure we don't break \pgf@up@draw@arrows@only
% - new code: search for "deco" to see if we missed anything
%
%
% Later
% -----
% - add "\else" in various places (likely better performance)
% - consider turning this into a pgf library, as it does not need TikZ
%   - only define /tikz/nfold in the skeleton tikz library
% - pull request to TikZ/pgf to simplify code injection
% - Do the subdivision of Bezier curves while parsing the soft path -> saves a lot of redundant calls
% - benchmark: Compare
%   - decorations approach
%   - new approach
%   - /tikz/double (i.e. not doing anything)
%   - Also: do the testing with nfold auto-set to 2 for a more realistic comparison with /tikz/double
% - fix closepath
% - update documentation
% - branch + pull request
% - Adapt the width of the bar in e.g. [arrows=|-Implies]



%
% Intercepting join settings
% --------------------------
%
% The current settings of the line joins are not stored in any TeX registers; instead, direct system
% calls are made to apply the settings. Therefore, we need to modify the pgf macros in order
% to cache the current settings.
%

% According to the pgf documentation, miter limit=10 is the default value,
% but I couldn't find and verify this setting in the pgf code
\gdef\pgf@nfold@cached@miterlimit{10}
\let\pgf@nfold@old@miterlimit\pgfsetmiterlimit
\def\pgfsetmiterlimit#1{%
  \pgf@nfold@old@miterlimit{#1}%
  \edef\pgf@nfold@cached@miterlimit{#1}%
}

% default line join is "miter"
\global\let\pgf@cached@linejoin=m% % b = bevel, m=miter, r=round
\let\pgf@nfold@old@setbeveljoin\pgfsetbeveljoin
\let\pgf@nfold@old@setmiterjoin\pgfsetmiterjoin
\let\pgf@nfold@old@setroundjoin\pgfsetroundjoin
\def\pgfsetbeveljoin{%
  \pgf@nfold@old@setbeveljoin%
  % do NOT change this globally! Needs to be changed back at the end of groups for scoping reasons
  \let\pgf@cached@linejoin=b%
}
\def\pgfsetmiterjoin{%
  \pgf@nfold@old@setmiterjoin%
  \let\pgf@cached@linejoin=m%
}
\def\pgfsetroundjoin{%
  \pgf@nfold@old@setroundjoin%
  \let\pgf@cached@linejoin=r%
}

%
% Various helper commands
% -----------------------

% check if a segment is visible, i.e. not moveto or last
% TODO add else's + error if not in the list
\newif\ifpgf@nfold@segm@visible
\def\checkpgfsegmentvisible#1{%
  \pgf@nfold@segm@visiblefalse%
  \ifx#1\pgf@nfold@inputsegmentlineto%
  \pgf@nfold@segm@visibletrue\fi%
  \ifx#1\pgf@nfold@inputsegmentcurveto%
  \pgf@nfold@segm@visibletrue\fi%
  \ifx#1\pgf@nfold@inputsegmentclosepath%
  \pgf@nfold@segm@visibletrue\fi%
}


%
% Joining offset lines
% --------------------
%
% One of the more difficult aspects is joining the segments of an offset path. Without this step,
% the path would be interrupted or self-intersect whenever there is a non-zero angle between
% two segments. This code reproduces the existing line joins "bevel", "miter" and "round".
%

\def\pgf@nfold@miterjoin{
  % The tip of the miter join is computed starting from the original (unshifted) centre of the join;
  % we then move orthorgonal to the average of the old and new angle
  \pgfpointadd%
    {\pgf@nfold@inputsegment@first}%
    {\pgfpointpolar%
      {\pgf@nfold@previous@endangle+.5*\pgf@nfold@deltaphi+90}% do not change
      {\pgf@shiftdec@amount/cos(.5*\pgf@nfold@deltaphi)}%
    }%
  \pgfpathlineto{}%
}

\def\pgf@nfold@beveljoin{
  % The bevel join for one component line consists of three parts:
  % 1) an extension of the ingoing line,
  % 2) a middle line, angled at the average of the incoming and outgoing line,
  % 3) an extension of the outgoing line.
  % Different components of the ingoing and outgoing lines have a constant distance from each other.
  % For a good-looking output, the mittle parts of the component lines thus should also have a constant distance,
  % which is a non-trivial condition. To generate such an output the outer lines get a bevel-like join
  % and the inner lines get a miter-like join; the threshold depends on deltaphi.
  % We first compute by how much the outermost line must be continued from the beginning of the join.
  % The protrusion amount must be lowered by a little bit for a rather complicated reason: The offset would be
  % dead on if the outermost offset line were centered on the _edge_ of the wide line, but we want to draw 
  % the outside line _fully inside_ the wide line. The factor of tan(deltaphi/4) can be derived, but is not obvious.
  \pgfmathsetlengthmacro{\bevelouterprotrusion}%
    {\pgf@nfold@shortenstartjoin - .5*\pgflinewidth*abs(tan(.25*\pgf@nfold@deltaphi))}
  % The following applies to middle lines only: We compute by how much they need to be shortened so the distance
  % between the lines in the join is correct.
  \pgfmathsetmacro{\bevelshorten}{2*\insidepercentage*abs(tan(.25*\pgf@nfold@deltaphi))}
  % This threshold decides if the inside line has a bevel or a miter join
  \pgfmathparse{\bevelshorten < abs(sin(.5*\pgf@nfold@deltaphi))}
  \ifnum\pgfmathresult=1\relax
    \pgfmathsetlengthmacro{\bevelextension}{\bevelouterprotrusion-\bevelshorten*\pgf@decoration@nfold@hwidth}
    \pgfpointadd{\pgf@nfold@join@start}{\pgfpointpolar{\pgf@nfold@previous@endangle}{\bevelextension}}
    \pgfpathlineto{}
    \pgfpointadd{\pgf@nfold@join@end}{\pgfpointpolar{\pgf@nfold@cur@startangle}{-\bevelextension}}
    \pgfpathlineto{}
  \else
    \pgf@nfold@miterjoin
  \fi
}

\def\pgf@nfold@roundjoin{
  % The outer half of the lines get arcs, the others get miters
  \ifdim\insidepercentage pt<.5pt\relax
    \pgfpointadd{\pgf@nfold@join@start}{\pgfpointpolar{\pgf@nfold@previous@endangle}{\pgf@nfold@shortenstartjoin}}
    \pgfpathlineto{}
    % Check if the angles are in the correct range; under some conditions we must add or subtract 360
    \pgfmathparse{\turnindicator*(\pgf@nfold@cur@startangle-\pgf@nfold@previous@endangle)}
    \ifdim\pgfmathresult pt>0pt\relax
      \pgfmathsetmacro{\targetang}{\pgf@nfold@cur@startangle-\turnindicator*360}
    \else
      \let\targetang\pgf@nfold@cur@startangle
    \fi
    \pgfpatharc%
      {\pgf@nfold@previous@endangle+90*\turnindicator}%
      {\targetang+90*\turnindicator}%
      {abs(\pgf@shiftdec@fraction)*\pgf@decoration@nfold@hwidth}%
  \else
    \pgf@nfold@miterjoin
  \fi
}

\def\pgf@nfold@make@join{
  % Offset the start and end of this join
  \pgfextract@process\pgf@nfold@join@start{%
    \pgfpointadd{\pgf@nfold@cached@endpoint}
                {\pgfpointpolar{\pgf@nfold@previous@endangle+90}{\pgf@shiftdec@amount}}}%
  \pgfextract@process\pgf@nfold@join@end{%
    \pgfpointadd{\pgf@nfold@segment@start}
                {\pgfpointpolar{\pgf@nfold@cur@startangle+90}{\pgf@shiftdec@amount}}}%
  \pgfpointdiff{\pgf@nfold@join@start}{\pgf@nfold@join@end}
  % Check if the start of this segment is too close to the end of the previous segment.
  % In that case we don't insert a join segment, as it would look rather glitchy.
  % We use the Manhattan length for performance and to avoid 'dimension too large' errors.
  \pgfmathparse{abs(\pgf@x) + abs(\pgf@y)}
  \ifdim\pgfmathresult pt>0.1pt\relax
    % First step: Check if left or right turn (-1 = left, 1=right)
    \ifdim\pgf@nfold@deltaphi pt<0pt
      \def\turnindicator{1}
    \else
      \def\turnindicator{-1}
    \fi
    % \insidepercentage: between 0.0 and 1.0;
    % 0=no distance to cover in the join, 1=maximum distance to cover
    \pgfmathsetmacro{\insidepercentage}{-.5*\turnindicator*\pgf@shiftdec@fraction+.5}
    \if m\pgf@cached@linejoin% \ifx is not needed because both are only one character
      % miter join
      % First we implement the miter limit: If the angle is too sharp, the miter join is replaced
      % by a bevel join. This is controlled by /tikz/miter limit=..., initially 10.
      \pgfmathsetmacro{\mitercosine}{abs(cos(.5*\pgf@nfold@deltaphi))}
      \pgfmathparse{\mitercosine*\pgf@nfold@cached@miterlimit}
      \ifdim\pgfmathresult pt>1pt\relax
        \pgf@nfold@miterjoin
      \else
        \pgf@nfold@beveljoin
      \fi
    \else
      \if b\pgf@cached@linejoin\relax
        \pgf@nfold@beveljoin
      \else
        \if r\pgf@cached@linejoin
          % round join
          \pgf@nfold@roundjoin
        \fi
      \fi
    \fi
    % All non-trivial joins connect to the end of the join, which is the starting point of the current segment.
    % Note that this entire macro is skipped by if the start and end of the join coincide, so we never create a zero length segment here.
    %
    % There is one edge case here: If two subsequent joins are so close that \pgf@nfold@segment@end
    % and \pgf@nfold@segment@start exchange places *and* we are on the outside of the join 
    % (implying that we are on the inside of the next join), \pgf@nfold@join@end will be located behind the next join.
    % In this case we instead connect to the offset of \pgf@nfold@segment@end (which comes *before* \pgf@nfold@segment@start).
    \pgf@nfold@join@end% default point to connect to
    \ifpgf@nfold@closejoinsedgecase%
      \ifdim\insidepercentage pt<.5pt\relax%
        \pgfpointadd{\pgf@nfold@segment@end}%
        {\pgfpointpolar{\pgf@nfold@cur@startangle+90}{\pgf@shiftdec@amount}}
      \fi%
    \fi
    \pgfpathlineto{}
  \fi
}


%
% Main rendering pipeline
% -----------------------
%

% This stores whether the current segment should begin with a moveto to its offset
\newif\ifpgf@nfold@continuesegment
% This stores whether we are in some edge case of very close joins, see below for details
\newif\ifpgf@nfold@closejoinsedgecase
% This stores whether we are in an error case where we need to avoid dividing by zero
\newif\ifpgf@nfold@angletoosharp



% TODO rename
\def\pgf@nfold@handlesegment@testoffset{%
  %%% Step 0: Preparation
  % Set some default values; they might get overwritten later
  \let\pgf@nfold@segment@start\pgf@nfold@inputsegment@first
  \let\pgf@nfold@segment@end\pgf@nfold@inputsegment@last
  % Set a default value for \ifpgf@nfold@continuesegment.
  % It may be overwritten by \pgf@nfold@extendtotip
  \ifx\pgf@nfold@previousinputsegment\pgf@nfold@inputsegmentmoveto
    \pgf@nfold@continuesegmentfalse
  \else
    \pgf@nfold@continuesegmenttrue
  \fi
  %%% Step 1: Make space for joins if necessary
  % In order to make space for the join, it may be necessary to shorten the current segment
  % at the start and/or the end. In here we store by how much the segment needs to be shortened.
  \def\pgf@nfold@shortenstartjoin{0pt}
  \def\pgf@nfold@shortenendjoin{0pt}
  \pgf@nfold@closejoinsedgecasefalse
  \pgf@nfold@angletoosharpfalse
  % Make a join only if two adjacent segments are both visible
  \checkpgfsegmentvisible\pgf@nfold@currentinputsegment
  \ifpgf@nfold@segm@visible%
    % Step 1.1: Make space for the join at the start if needed
    \ifx\pgf@nfold@previousinputsegment\pgf@nfold@inputsegmentmoveto\else
      % TODO Future idea: Also check if we move backwards further than the length of the line plus one (or two) hwidth's
      \pgfmathparse{abs(\pgf@nfold@deltaphi@start) > 178}
      \ifnum\pgfmathresult=1\relax
        % we go full backwards, don't relocate the start and disable the join to avoid division by zero
        \pgfwarning{Angle too sharp in 'nfold', expect visual errors}
        \pgf@nfold@angletoosharptrue
      \else
        \pgfmathsetlengthmacro{\pgf@nfold@shortenstartjoin}%
          {\pgf@decoration@nfold@hwidth*abs(tan(0.5*\pgf@nfold@deltaphi@start))}
        \pgfextract@process\pgf@nfold@segment@start{%
          \pgfpointadd{\pgf@nfold@inputsegment@first}%
                      {\pgfpointpolar{\pgf@nfold@cur@startangle}{\pgf@nfold@shortenstartjoin}}}%
      \fi
    \fi
    % Step 1.2: Make space for the join at the end if needed
    \checkpgfsegmentvisible\pgf@nfold@next@segmenttype
    \ifpgf@nfold@segm@visible%
      \pgfmathparse{abs(\pgf@nfold@deltaphi@end) > 178}
      \ifnum\pgfmathresult=1\relax
        % we go full backwards, don't relocate the start
        \pgfwarning{Angle too sharp in 'nfold', expect visual errors}
      \else
        \pgfmathsetlengthmacro{\pgf@nfold@shortenendjoin}%
          {\pgf@decoration@nfold@hwidth*abs(tan(0.5*\pgf@nfold@deltaphi@end))}
        \pgfextract@process\pgf@nfold@segment@end{%
          \pgfpointadd{\pgf@nfold@inputsegment@last}%
                      {\pgfpointpolar{\pgf@nfold@cur@endangle}{-\pgf@nfold@shortenendjoin}}}%
      \fi
      % Step 1.3: Detect an edge case
      % This edge case appears whenever the current segment is such a short line that we would
      % have to reduce its length to less than zero to make space for the joins. In such cases,
      % the line is not drawn at all, and slight modifications must be made to the joins to ensure
      % a correct output (i.e. one join is immediately followed by the next without a segment in between).
      %
      % This edge case can appear for curves as well, but they are much harder to deal with.
      \ifx\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentlineto
        % No need to check for \pgf@nfold@inputsegmentclosepath as it should not be followed by any further segments
        % Now: Check if the total amount of shortening is larger than the length of the segment
        \pgfpointdiff{\pgf@nfold@inputsegment@first}{\pgf@nfold@inputsegment@last}
        \pgfmathparse{\pgf@nfold@shortenstartjoin+\pgf@nfold@shortenendjoin > veclen(\pgf@x,\pgf@y)}
        \ifnum\pgfmathresult=1\relax
          \pgf@nfold@closejoinsedgecasetrue
        \fi
      \fi
    \fi% end if next segment visible
    %
    % Step 2.1: Draw the join at the start if applicable
    %
    \ifx\pgf@nfold@previousinputsegment\pgf@nfold@inputsegmentmoveto
      \ifpgf@nfold@closejoinsedgecase
        % If the previous segment is a moveto and the current segment is a "close joins" edge case,
        % nothing needs to be drawn here (the relevant draw call will be made at the join of the subsequent
        % segment). We must therefore make sure that we move to the correct end point of this segment.
        % Counterintuitively, this is given by the offset of \pgf@nfold@segment@start since the start and end
        % are reversed in the edge case.
        \pgfpointadd%
          {\pgf@nfold@segment@start}%
          {\pgfpointpolar{\pgf@nfold@cur@startangle+90}{\pgf@shiftdec@amount}}
        \pgfpathmoveto{}
       \fi
    \else
      % TODO pass the angle as a parameter instead?
      % If we draw the lines when the start angle is close to 180 degrees, we get a division by zero 
	  \ifpgf@nfold@angletoosharp\else
        \let\pgf@nfold@deltaphi\pgf@nfold@deltaphi@start
        \pgf@nfold@make@join
      \fi
    \fi
  \fi% end if current segment visible
  % Step 2.2: Store where the current (non-offset) end point was relocated
  % in order to make space for the end join. This will be used
  % when wed draw the join at the start of the next segment
  \ifx\pgf@nfold@next@inputsegment\pgf@nfold@inputsegmentmoveto\else
    \global\let\pgf@nfold@cached@endpoint\pgf@nfold@segment@end
  \fi
  %
  % Step 3: Draw the new segment.
  %
  % The value of \ifpgf@nfold@continuesegment decides whether we start with a moveto.
  \ifx\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentlineto
    \ifpgf@nfold@closejoinsedgecase\else
      \ifpgf@nfold@continuesegment
        \pgfoffsetlinenomove{\pgf@nfold@segment@start}{\pgf@nfold@segment@end}{\pgf@shiftdec@amount}
      \else
        \pgfoffsetline{\pgf@nfold@segment@start}{\pgf@nfold@segment@end}{\pgf@shiftdec@amount}
      \fi
    \fi
  \fi
  \ifx\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentclosepath
    % Incomplete: proper join is missing
    % Idea: when parsing the path, add a detection if there is a closepath at the current segment,
    % then cache the data of the last segment.
    % We could then insert a "fake previous segment" into the path at the right place
    \pgfwarning{'nfold': The option 'cycle' is not yet properly supported.}
    \pgfpathclose
% TODO Old code, likely no longer needed
%      \ifpgf@nfold@continuesegment
%        \pgfoffsetlinenomove{\pgf@nfold@segment@start}{\pgf@nfold@segment@end}{\pgf@shiftdec@amount}
%      \else
%        \pgfoffsetline{\pgf@nfold@segment@start}{\pgf@nfold@segment@end}{\pgf@shiftdec@amount}
%      \fi
  \fi
  \ifx\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentcurveto
    \ifpgf@nfold@continuesegment
      \pgfoffsetcurvenomove{\pgf@nfold@segment@start}{\pgf@nfold@inputsegment@supporta}{\pgf@nfold@inputsegment@supportb}{\pgf@nfold@segment@end}{\pgf@shiftdec@amount}
    \else
      \pgfoffsetcurve{\pgf@nfold@segment@start}{\pgf@nfold@inputsegment@supporta}{\pgf@nfold@inputsegment@supportb}{\pgf@nfold@segment@end}{\pgf@shiftdec@amount}
    \fi
  \fi
  \ifx\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentmoveto
    % Every moveto is executed in the offsetting of the subsequent draw command
    % and is thus not needed here
    \ifx\pgf@nfold@previousinputsegment\pgf@nfold@inputsegmentfirst
      % Draw the tip extension at the start (if present)
      \ifnum\pgf@nfold@start@arrowcode=1
        \pgf@nfold@extendtotip{s}%
      \fi%
    \fi
  \fi
  % Step 4: Extend into the arrow tip at the end (if present)
  \ifx\pgf@nfold@next@segmenttype\pgf@nfold@inputsegmentlast%
    \ifnum\pgf@nfold@end@arrowcode=1
      \pgf@nfold@extendtotip{e}%
    \fi%
  \fi%
}


% Rendering arrow tips
% --------------------

% Precomputed intersections
%
% For arrows of order n > 2 with an Implies tip, the constituent parts of the n-fold arrow
% end somewhere in the middle of the tip. The exact end point must be computed using
% the intersections library. To speed up compilation times, the intersection points are precomputed
% up to n = 5. If your document contains arrows of order 6 or larger, consider adding those
% as well; the values are output in the log file.
\expandafter\def\csname tikz@arrow@intersec@cache@2@3\endcsname{\pgfqpoint{2pt}{0pt}}
\expandafter\def\csname tikz@arrow@intersec@cache@2@4\endcsname{\pgfqpoint{0.94063pt}{-0.33333pt}}
\expandafter\def\csname tikz@arrow@intersec@cache@3@4\endcsname{\pgfqpoint{0.94063pt}{0.33333pt}}
\expandafter\def\csname tikz@arrow@intersec@cache@2@5\endcsname{\pgfqpoint{0.64167pt}{-0.5pt}}
\expandafter\def\csname tikz@arrow@intersec@cache@3@5\endcsname{\pgfqpoint{2pt}{0pt}}
\expandafter\def\csname tikz@arrow@intersec@cache@4@5\endcsname{\pgfqpoint{0.64167pt}{0.5pt}}
% intersections are precomputed up to this order
\def\tikz@arrow@intersec@numcached{5}

% This macro extends the arrow body to the tips
% parameter: s=start, e=end
\def\pgf@nfold@extendtotip#1{
  % Do not extend the arrow for index=1 and index=order, it already ends in the right place
  \ifnum\pgf@nfold@index>1\relax\ifnum\pgf@nfold@index<\pgf@nfold@order\relax%
    % Step 1: Find the intersection of the arrow's path with the head
    \ifcsname tikz@arrow@intersec@cache@\the\pgf@nfold@index @\the\pgf@nfold@order\endcsname
      \pgfextract@process\pgf@nfold@arrowintersect
        {\csname tikz@arrow@intersec@cache@\the\pgf@nfold@index @\the\pgf@nfold@order\endcsname}%
    \else
      % the intersection has not been precomputed, thus compute on the fly here
      \pgfintersectionofpaths{
        % specify the tip
        \pgfpathmoveto{\pgfqpoint{-1.4pt}{2.65pt}}
        \pgfpathcurveto{\pgfqpoint{-0.75pt}{1.25pt}}{\pgfqpoint{1pt}{0.05pt}}{\pgfqpoint{2pt}{0pt}}
        \pgfpathcurveto{\pgfqpoint{1pt}{-0.05pt}}{\pgfqpoint{-0.75pt}{-1.25pt}}{\pgfqpoint{-1.4pt}{-2.65pt}}
      }{
        % extend the body to intersect the tip
        \pgfpathmoveto{\pgfqpoint{-3pt}{\pgf@shiftdec@fraction pt}}
        \pgfpathlineto{\pgfqpoint{3pt}{\pgf@shiftdec@fraction pt}}
      }
      \ifnum\pgfintersectionsolutions>0
        \pgfextract@process\pgf@nfold@arrowintersect{\pgfpointintersectionsolution{1}}%
        \typeout{tikz-nfold: computed intersection cache@\the\pgf@nfold@index @\the\pgf@nfold@order: \string\pgfqpoint{\the\pgf@x}{\the\pgf@y}^^J}
        % add the new intersection to the cache
        \expandafter\xdef\csname tikz@arrow@intersec@cache@\the\pgf@nfold@index @\the\pgf@nfold@order\endcsname{\noexpand\pgfqpoint{\the\pgf@x}{\the\pgf@y}}
      \else
        % this is a failsafe and should never be reached
        \pgfwarning{'nfold': did not find intersection}
        \pgfextract@process\pgf@nfold@arrowintersect{\pgfqpoint{0pt}{\pgf@shiftdec@fraction pt}}%
      \fi
    \fi% if precomputed
  % Step 2: Extend the arrow body to the intersection point.
  % If the tip is at the beginning of the path, we have to move to the intersection
  % and then draw a line to the "regular" starting point. The subsequent segment then
  % should omit its moveto.
  % If the tip is at the end, we are already in the right position and only need to extend
  % the current path to the intersection point.
  \begingroup
    \pgftransformreset
    \if#1s
      \pgftransformshift{\pgf@nfold@segment@start}
      \pgftransformrotate{\pgf@nfold@next@startangle}
      \pgftransformxscale{-1}
    \else
      \pgftransformshift{\pgf@nfold@segment@end}
      \pgftransformrotate{\pgf@nfold@cur@endangle}
    \fi
    % we don't want to undo the shift by .42\pgflinewidth after the scaling
    \pgfutil@tempdima=\pgf@decoration@nfold@hwidth
    \pgfutil@tempdima=\pgf@shiftdec@fraction\pgfutil@tempdima
    \pgfextract@process\pgf@nfold@startofextension
      {\pgfpointtransformed{\pgfqpoint{0pt}{\pgfutil@tempdima}}}
    % 0.5 - 0.06 = 0.42
    \pgftransformshift{\pgfqpoint{.42\pgflinewidth}{0pt}}
    \pgftransformscale{\pgf@decoration@nfold@hwidth}
    \pgfextract@process\pgf@nfold@arrowintersect{\pgfpointtransformed{\pgf@nfold@arrowintersect}}
    \global\let\pgf@nfold@startofextension\pgf@nfold@startofextension
    \global\let\pgf@nfold@arrowintersect\pgf@nfold@arrowintersect
  \endgroup
  \if#1s
    \pgfpathmoveto{\pgf@nfold@arrowintersect}
    % This is precisely the start of the body, shifted vertically
    \pgfpathlineto{\pgf@nfold@startofextension}
    % hack: We make the next segment believe that this segment was a lineto
    % so the path does not get interrupted
    \let\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentlineto
    \let\pgf@nfold@cur@endangle\pgf@nfold@next@startangle
  \else\if#1e
    \pgfpathlineto{\pgf@nfold@arrowintersect}
  \else
    \pgferror{Invalid argument to \string\pgf@nfold@extendtotip: \meaning#1}
  \fi\fi
  \pgftransformreset
\fi\fi% if 1 < i < nArrows
}

% Parsing the arrow tips
% ----------------------
%
% We need to detect if the user has set Implies[] arrows at the start and/or end tip.
% To do so, we parse \pgf@start@tip@sequence. If the user specifies Implies[] manually,
% we find that
%   pgf@start@tip@sequence=\pgf@arrow@handle{Implies}{...}
% However, in other cases (like tikz-cd) we may find 
%   \pgf@arrow@handle@shorthand@empty {\csname pgf@ar@means@tikzcd implies cap\endcsname }
% In such cases we must expand the first parameter once and then match as above.

\def\pgf@nfold@parsearrows{
  \ifpgfutil@tempswa% this is set in \pgfusepath and stores whether we draw arrow tips at all
    \expandafter\pgf@nfold@parsearrowmacro\pgf@start@tip@sequence\relax
    \let\pgf@nfold@start@arrowcode\pgf@nfold@detectedarrow
    \expandafter\pgf@nfold@parsearrowmacro\pgf@end@tip@sequence\relax
    \let\pgf@nfold@end@arrowcode\pgf@nfold@detectedarrow
  \else
    \def\pgf@nfold@start@arrowcode{0}
    \def\pgf@nfold@end@arrowcode{0}
  \fi
}

\def\pgf@nfold@parsearrowmacro#1{%
  \def\pgf@nfold@detectedarrow{0}
  \ifx#1\relax
    \let\pgf@next\relax
  \else
    \ifx#1\pgf@arrow@handle
      % found \pgf@arrow@handle{...}, now parse the first parameter
      \let\pgf@next\pgf@nfold@parse@arrow@handle
    \else
      \ifx#1\pgf@arrow@handle@shorthand@empty
        \let\pgf@next\pgf@nfold@parse@shorthandempty
      \else
        % found nothing
        \let\pgf@next\pgfutil@gobble@until@relax
      \fi
    \fi
  \fi
  \pgf@next
}

\def\pgf@nfold@param@Implies{Implies}

\def\pgf@nfold@parse@arrow@handle#1{%
  \def\pgf@tmp{#1}
  \ifx\pgf@tmp\pgf@nfold@param@Implies
    \def\pgf@nfold@detectedarrow{1}
  \fi
  \pgfutil@gobble@until@relax
}

\def\pgf@nfold@parse@shorthandempty#1{
  % Expand #1 once (\pgf@arrow@handle@shorthand@empty is just an identity operator)
  \expandafter\def\expandafter\pgf@tmp\expandafter{#1}
  \expandafter\pgf@nfold@parsearrowmacro\pgf@tmp\relax
  % still need to gobble the rest of the orginal arrow definition
  \pgfutil@gobble@until@relax
}


%
% Hooking into pgf's rendering pipeline
% -------------------------------------
%
% The new code has to be injected into \pgfusepath (pgfcorepathusage.code.tex). For rendering the new paths,
% \pgf@stroke@inner@line is a natural choice as this is where /tikz/double is rendered. However, we also
% need to disable rendering the ordinary path, which is not as easy. In the future I will make a pull request
% to TikZ to simplify such injections.
%
% The call to draw the path comes right before \pgf@stroke@inner@line. The macro before \pgf@stroke@inner@line
% is either \pgf@path@check@proper or \pgf@prepare@start@of@path (depending on the result of the proper check).
% We therefore must inject code into both of them to see if nfold is enabled. If it is, we call the old macro,
% cache and delete the current softpath (so the call to \pgfsyssoftpath@invokecurrentpath has no effect), then we
% restore and offset the cached softpath in \pgf@stroke@inner@line.
%
% TODO: The only other places where \pgf@path@check@proper and \pgf@prepare@start@of@path show up is in
% \pgf@up@draw@arrows@only; we must make sure that this call remains unmodified. Further changes are likely necessary.
%

\newcount\pgf@nfold@order
\pgf@nfold@order=1

\def\pgf@nfold@preparenfoldpath{%
  \ifnum\pgf@nfold@order>1\relax
    \ifdim\pgfinnerlinewidth>0pt\relax
      % Hack the rendering pipeline: There is a \pgfsyssoftpath@invokecurrentpath call following
      % which we do not want if nfold is active. We therefore clear the current path here
      % and then perform the nfold drawing in our modification of \pgf@stroke@inner@line
      \pgfsyssoftpath@getcurrentpath\cachedpath%
      \pgfsyssoftpath@setcurrentpath\pgfutil@empty%
    \else
      \pgferror{TODO: This is probably the error "must enable /tikz/double to use nfold"; can this occur under different circumstances?}
    \fi
  \fi
}

\let\pgf@nfold@old@path@check@proper\pgf@path@check@proper
\def\pgf@path@check@proper{%
  \pgf@nfold@old@path@check@proper%
  \ifpgfutil@tempswa\else
    % if \pgfutil@tempswa is false, this is the last macro we can overwrite before the draw call.
    % Otherwise, we inject into \pgf@prepare@start@of@path%
    \pgf@nfold@preparenfoldpath%
  \fi%
}

\let\pgf@nfold@old@prepare@start@of@path\pgf@prepare@start@of@path
\def\pgf@prepare@start@of@path{%
  \pgf@nfold@old@prepare@start@of@path%
  \pgf@nfold@preparenfoldpath%
}

\let\pgf@nfold@old@stroke@inner@line\pgf@stroke@inner@line
\def\pgf@stroke@inner@line{%
  \ifnum\pgf@nfold@order>1\relax%
    \pgf@nfold@render@cached@softpath%
  \else%
    % Old behaviour
    \pgf@nfold@old@stroke@inner@line%
  \fi%
}


%
% Parsing the soft path
% ---------------------
%
% A significant part of the code below is based on pgfmoduledecorations.code.tex (c) 2019 Mark Wibrow and Till Tantau.
% Quite similar to decorations we parse the current soft path and put it into a form that makes it easier
% to iterate over.
%
%

\def\pgf@nfold@parsesoftpath#1#2{%
  \def\pgf@nfold@inputsegmentobjectsmacro{#2}%
  \let\pgf@nfold@inputsegmentobjects\pgfutil@empty%
  \pgfutil@tempdima0pt\relax%
  \edef\pgfpoint@nfold@lastparsed{\pgf@x\the\pgf@path@lastx\pgf@y\the\pgf@path@lasty}%
  \let\pgfpoint@nfold@lastnonmovetoparsed\pgfpoint@origin%
  \let\pgf@nfold@queueinputsegmentobject\pgfutil@empty%
  \let\pgfpoint@nfoldd@firstparsed\pgfutil@empty%
  \expandafter\pgf@nfold@@parsesoftpath#1\pgf@stop%
}%

\def\pgf@nfold@@parsesoftpath#1{%
  \ifx#1\pgf@stop%
    \let\pgf@nfold@queueinputsegmentobject\pgfutil@empty% <- removes final moveto (may not be desirable).
    \pgf@nfold@addtoinputsegmentobjects{\pgf@nfold@inputsegmentobject@endofinputsegments}%
		% probably so that the last segment also has a well-defined next segment
    \pgf@nfold@addtoinputsegmentobjects{\pgf@nfold@inputsegmentobject@endofinputsegments}%
    \expandafter\let\pgf@nfold@inputsegmentobjectsmacro\pgf@nfold@inputsegmentobjects%
    \let\pgf@next\relax%
  \else%
    \ifx#1\pgfsyssoftpath@movetotoken%
      \let\pgf@next\pgf@nfold@parsemoveto%
    \else%
      \ifx#1\pgfsyssoftpath@linetotoken%
        \let\pgf@next\pgf@nfold@parselineto%
      \else%
        \ifx#1\pgfsyssoftpath@curvetosupportatoken%
          \let\pgf@next\pgf@nfold@parsecurveto%
        \else%
          \ifx#1\pgfsyssoftpath@closepathtoken%
            \let\pgf@next\pgf@nfold@parseclosepath%
% TODO test and implement rect's
%          \else%
%            \ifx#1\pgfsyssoftpath@rectcornertoken%
%              \let\pgf@next\pgf@nfold@parserect%
%            \else%
%              \pgferror{Unrecognised soft path token `#1'}%
%            \fi%
          \fi%
        \fi%
      \fi%
    \fi%
  \fi%
  \pgf@next}%


\def\pgf@nfold@parsemoveto#1#2{%
  \def\pgf@nfold@queueinputsegmentobject{\pgf@nfold@inputsegmentobject@moveto{\pgf@x#1\pgf@y#2}}%
  \def\pgfpoint@nfold@lastparsed{\pgf@x#1\pgf@y#2}%
  \pgf@nfold@@parsesoftpath%
}%

% Convert \pgfsyssoftpath@linetotoken{<X>}{<Y>} into the following
% representation:
%
% \pgf@nfold@inputsegmentobject@lineto{<length>}{\pgf@x <Last X> \pgf@y <Last Y>}{\pgf@x <X> \pgf@y <Y>}
%
\def\pgf@nfold@parselineto#1#2{%
  % remove degenerate line segments (reduces glitches)
  \pgf@process{\pgfpointdiff{\pgfpoint@nfold@lastparsed}{\pgf@x#1\pgf@y#2}}
  \pgfoffset@abssum\pgf@xa
  \ifdim\pgf@xa>.1pt\relax
    \edef\pgf@nfold@temp{%
      \noexpand\pgf@nfold@inputsegmentobject@lineto{0 pt}{\pgfpoint@nfold@lastparsed}{\pgf@x#1\pgf@y#2}%
    }%
    \edef\pgfpoint@nfold@lastparsed{\pgf@x#1\pgf@y#2}%
    \let\pgfpoint@nfold@lastnonmovetoparsed\pgfpoint@nfold@lastparsed%
    \expandafter\pgf@nfold@addtoinputsegmentobjects\expandafter{\pgf@nfold@temp}%
  \fi
  \pgf@nfold@@parsesoftpath%
}%

\def\pgf@nfold@parsecurveto#1#2\pgfsyssoftpath@curvetosupportbtoken#3#4\pgfsyssoftpath@curvetotoken#5#6{%
%  \pgf@decorate@curvelength{\pgfpoint@decorate@lastparsed}{\pgf@x#1\pgf@y#2}{\pgf@x#3\pgf@y#4}{\pgf@x#5\pgf@y#6}%
%  \advance\pgfutil@tempdima\pgfmathresult pt\relax%
  \edef\pgf@nfold@temp{%
    \noexpand\pgf@nfold@inputsegmentobject@curveto{0 pt}{\pgfpoint@nfold@lastparsed}%
      {\pgf@x#1\pgf@y#2}{\pgf@x#3\pgf@y#4}{\pgf@x#5\pgf@y#6}%
  }%
  \expandafter\pgf@nfold@addtoinputsegmentobjects\expandafter{\pgf@nfold@temp}%
  \edef\pgfpoint@nfold@lastparsed{\pgf@x#5\pgf@y#6}%
  \let\pgfpoint@nfold@lastnonmovetoparsed\pgfpoint@nfold@lastparsed%
  \pgf@nfold@@parsesoftpath%
}%

\def\pgf@nfold@parseclosepath#1#2{%
  \edef\pgf@nfold@temp{%
    \noexpand\pgf@nfold@inputsegmentobject@closepath{0 pt}{\pgfpoint@nfold@lastparsed}{\pgf@x#1\pgf@y#2}%
  }%
  \let\pgfpoint@nfold@lastnonmovetoparsed\pgfpoint@nfold@lastparsed%
  \expandafter\pgf@nfold@addtoinputsegmentobjects\expandafter{\pgf@nfold@temp}%
  \pgf@nfold@@parsesoftpath%
}%

\def\pgf@nfold@addtoinputsegmentobjects#1{%
  %
  % If there is an input segment object waiting (i.e. a moveto), insert it here.
  %
  \ifx\pgf@nfold@queueinputsegmentobject\pgfutil@empty%
  \else%
    \let\pgf@nfold@temp\pgf@nfold@queueinputsegmentobject%
    \let\pgf@nfold@queueinputsegmentobject\pgfutil@empty%
    \expandafter\pgf@nfold@addtoinputsegmentobjects\expandafter{\pgf@nfold@temp}%
  \fi%
  \ifx\pgfpoint@nfold@firstparsed\pgfutil@empty%
    #1%
    \let\pgfpoint@nfold@firstparsed\pgf@nfold@inputsegment@first%
  \fi%
  \expandafter\def\expandafter\pgf@nfold@inputsegmentobjects\expandafter%
    {\pgf@nfold@inputsegmentobjects{#1}}%
}%




%% Components of the path, modified
\def\pgf@nfold@inputsegmentfirst{first}%
\def\pgf@nfold@inputsegmentmoveto{moveto}%
\def\pgf@nfold@inputsegmentlineto{lineto}%
\def\pgf@nfold@inputsegmentcurveto{curveto}%
\def\pgf@nfold@inputsegmentclosepath{closepath}%
\def\pgf@nfold@inputsegmentlast{last}%


\def\pgf@nfold@inputsegmentobject@moveto#1{%
  \def\pgf@nfold@inputsegment@first{#1}%
  \def\pgf@nfold@inputsegment@supporta{#1}%
  \def\pgf@nfold@inputsegment@supportb{#1}%
  \def\pgf@nfold@inputsegment@last{#1}%
  \edef\pgf@nfold@lastmoveto{#1}%
  \let\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentmoveto%
}%


% TODO remove the #1 length parameter from all of these (and also above)

\def\pgf@nfold@inputsegmentobject@lineto#1#2#3{%
  \def\pgf@nfold@inputsegment@first{#2}%
  \def\pgf@nfold@inputsegment@last{#3}%
  \let\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentlineto%
}%

\def\pgf@nfold@inputsegmentobject@curveto#1#2#3#4#5{%
  \def\pgf@nfold@inputsegment@first{#2}%
  \def\pgf@nfold@inputsegment@supporta{#3}%
  \def\pgf@nfold@inputsegment@supportb{#4}%
  \def\pgf@nfold@inputsegment@last{#5}%
  \let\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentcurveto%
}%

\def\pgf@nfold@inputsegmentobject@closepath#1#2#3{%
  \def\pgf@nfold@inputsegment@first{#2}%
  \def\pgf@nfold@inputsegment@last{#3}%
  \let\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentclosepath%
}%

\def\pgf@nfold@inputsegmentobject@endofinputsegments{%
  \let\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentlast%
}%


\def\pgf@nfold@traversepath{%
  % Transformations are already baked into the path; without this call, they will be applied twice
  \pgftransformreset
  % could likely also use \let\pgf@nfold@currentinputsegmentobjects\parsedsoftpath here
  \let\pgf@nfold@currentinputsegmentobjects\pgf@nfold@inputsegmentobjects%
%  \let\pgf@nfold@transformtoinputsegment\pgfutil@empty% we may need this one for closepath
  \pgf@nfold@getnextinputsegmentobject\pgf@nfold@nextinputsegmentobject%
  \let\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentfirst%
  \def\pgf@nfold@cur@endangle{0.0}% put in some default value so \pgf@nfold@previous@endangle is not undefined
  \pgf@nfold@traversepath@
}


\def\pgf@nfold@traversepath@{
  \pgf@nfold@processnextinputsegmentobject%
  \ifx\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentlast\else
    \pgf@nfold@handlesegmentmacro%
  \fi%
  \ifx\pgf@nfold@currentinputsegmentobjects\pgfutil@empty%
    \let\pgf@next\relax%
  \else%
    \let\pgf@next\pgf@nfold@traversepath@%
  \fi%
  \pgf@next%
}


\def\pgf@nfold@computeangles{
  % TODO add the improved code for partially singular curves here
  \ifx\pgf@nfold@currentinputsegment\pgf@nfold@inputsegmentcurveto%
    \pgfmathanglebetweenpoints{\pgf@nfold@inputsegment@first}{\pgf@nfold@inputsegment@supporta}%
    \edef\pgf@nfold@cur@startangle{\pgfmathresult}
    \pgfmathanglebetweenpoints{\pgf@nfold@inputsegment@supportb}{\pgf@nfold@inputsegment@last}%
    \edef\pgf@nfold@cur@endangle{\pgfmathresult}
  \else%
    \pgfmathanglebetweenpoints{\pgf@nfold@inputsegment@first}{\pgf@nfold@inputsegment@last}%
    \edef\pgf@nfold@cur@startangle{\pgfmathresult}
    \edef\pgf@nfold@cur@endangle{\pgfmathresult}
  \fi%
}

\def\pgf@nfold@clampangle{
  % The computed angles are values between 0 and 360, so their difference is between 360 and -360;
  % we want the difference to be between -180 and 180
  % This can also be done using one \pgfmathparse and Mod, but this is more efficient
  \ifdim\pgfmathresult pt<-180pt\relax
    \pgfutil@tempdima=\pgfmathresult pt
    \advance\pgfutil@tempdima by 360pt
    \edef\pgfmathresult{\pgf@sys@tonumber\pgfutil@tempdima}
  \else\ifdim\pgfmathresult pt>180pt\relax
    \pgfutil@tempdima=\pgfmathresult pt
    \advance\pgfutil@tempdima by -360pt
    \edef\pgfmathresult{\pgf@sys@tonumber\pgfutil@tempdima}
  \fi\fi
}

\def\pgf@nfold@getnextinputsegmentobject#1{%
  \ifx\pgf@nfold@currentinputsegmentobjects\pgfutil@empty%
    \let\pgf@next\relax%
  \else%
    \def\pgf@nfold@temp{#1}%
    \let\pgf@next\pgf@nfold@@getnextinputsegmentobject%
  \fi%
  \pgf@next%
}%
\def\pgf@nfold@@getnextinputsegmentobject{%
  \expandafter\pgf@nfold@@@getnextinputsegmentobject\pgf@nfold@currentinputsegmentobjects\pgf@stop}%
\def\pgf@nfold@@@getnextinputsegmentobject#1#2\pgf@stop{%
  \expandafter\def\pgf@nfold@temp{#1}%
  \def\pgf@nfold@currentinputsegmentobjects{#2}}%

\def\pgf@nfold@processnextinputsegmentobject{%
  \let\pgf@nfold@previousinputsegment\pgf@nfold@currentinputsegment%
  \let\pgf@nfold@previous@endangle\pgf@nfold@cur@endangle%
  \let\pgf@nfold@currentinputsegmentobject\pgf@nfold@nextinputsegmentobject%
  \pgf@nfold@getnextinputsegmentobject\pgf@nfold@nextinputsegmentobject%
  % TODO We may be able to optimise away redundant calls here in the future
  \pgf@nfold@nextinputsegmentobject% parse the *next* input segment so we can compute its angles
  \pgf@nfold@computeangles%
  \let\pgf@nfold@next@first\pgf@nfold@inputsegment@first%
  \let\pgf@nfold@next@supporta\pgf@nfold@inputsegment@supporta%
  \let\pgf@nfold@next@supportb\pgf@nfold@inputsegment@supportb%
  \let\pgf@nfold@next@last\pgf@nfold@inputsegment@last%
  \let\pgf@nfold@next@segmenttype\pgf@nfold@currentinputsegment%
  \let\pgf@nfold@next@startangle\pgf@nfold@cur@startangle%
  \pgf@nfold@currentinputsegmentobject% get the current segment into \pgf@nfold@inputsegment@first etc.
  \pgf@nfold@computeangles%
  % Compute the angle differences at the start and end (between -180 and +180 degrees)
  \pgfmathparse{\pgf@nfold@cur@startangle-\pgf@nfold@previous@endangle}
  \pgf@nfold@clampangle
  \edef\pgf@nfold@deltaphi@start{\pgfmathresult}
  \pgfmathparse{\pgf@nfold@next@startangle-\pgf@nfold@cur@endangle}
  \pgf@nfold@clampangle
  \edef\pgf@nfold@deltaphi@end{\pgfmathresult}
}


%
% Iterating over the parsed soft path
% -----------------------------------
%

\newcount\pgf@nfold@index
\def\pgf@nfold@run@loop{%
  \pgf@nfold@index=\pgf@nfold@order%
  \pgf@nfold@run@loop@%
}

\def\pgf@nfold@run@loop@{%
  \pgf@nfold@loop@inner%
  \advance\pgf@nfold@index by -1\relax
  \ifnum\pgf@nfold@index>0\relax%
    \pgf@nfold@run@loop@%
  \fi%
}

\def\pgf@nfold@loop@inner{%
  \pgfmathsetmacro{\pgf@shiftdec@fraction}%
    {-1+2*(\pgf@nfold@index-1)/(\pgf@nfold@order-1)}
  \pgfmathsetlengthmacro{\pgf@shiftdec@amount}{\pgf@decoration@nfold@hwidth*\pgf@shiftdec@fraction}
  \let\pgf@nfold@handlesegmentmacro\pgf@nfold@handlesegment@testoffset
  \pgf@nfold@traversepath%
  \pgfsyssoftpath@flushcurrentpath%
  \pgf@up@action%
}

% Computes both the width of the component lines into \pgf@x and the distance
% from the center to the outermost line centers into \pgf@y
% from the current values of \pgflinewidth and \pgfinnerlinewidth.
\def\pgf@nfold@compute@widths@from@double{
    \pgf@x=\pgflinewidth\relax%
    \pgf@y=\pgf@x\relax%
    \advance\pgf@x-\pgfinnerlinewidth\relax%
    \advance\pgf@y+\pgfinnerlinewidth\relax%
    \pgf@x=.5\pgf@x\relax%
    \pgf@y=.25\pgf@y\relax%
}

\def\pgf@nfold@render@cached@softpath{%
  \pgfscope% must use a scope, otherwise we break the arrow tips
    \pgfprocessround{\cachedpath}{\cachedpath}% remove tokens from the soft path
    \pgf@nfold@parsesoftpath{\cachedpath}{\parsedsoftpath}
    \pgf@nfold@parsearrows
    % Compute the full and constituent part line widths
    \pgf@nfold@compute@widths@from@double%
    \pgfsetlinewidth\pgf@x%
    \edef\pgf@decoration@nfold@hwidth{\the\pgf@y}
    \pgf@nfold@run@loop
  \endpgfscope
}


%
% pgf keys / user interface
% -------------------------
%

\pgfkeys{
  /pgf/nfold/.code={%
    \pgf@nfold@order=#1\relax%
    \ifnum\pgf@nfold@order<1\relax%
      \pgferror{'nfold' must take a value of at least 1, got \the\pgf@nfold@order}%
    \fi%
  },
  /pgf/nfold/.default=2
}


% use \tikzset for scoping reasons, does not appear to be equivalent to \pgfset{/tikz/...=...}
\tikzset{
  nfold/.code={
    \edef\pgf@tmp{\noexpand\pgfkeys{/pgf/nfold=#1}}
    % patch \tikz@double@setup to set /pgf/nfold=#1 as well
    \expandafter\expandafter\expandafter\def%
      \expandafter\expandafter\expandafter\tikz@double@setup%
      \expandafter\expandafter\expandafter{\expandafter\tikz@double@setup\pgf@tmp}
  },
  nfold/.default=2,
  % TODO add scaling nfold to documentation
  scaling nfold/.code={%
    \pgfscope% scope to contain \tikz@double@setup
      \tikz@double@setup
      % extract double distance between line centers into \pgf@x
      \pgf@nfold@compute@widths@from@double
      \pgf@y=2\pgf@y
      % store (order-1)*\pgf@x in \pgf@xa
      \c@pgf@counta=#1
      \advance\c@pgf@counta by -1\relax
      \global\pgf@y=\c@pgf@counta\pgf@y
    \endpgfscope
    \tikzset{
      double distance between line centers=\pgf@y,
      nfold=#1
    }
  },
  scaling nfold/.default=2,
  % This simply defines the key if tikzcd is not loaded, so we don't run into any errors
  commutative diagrams/scaling nfold/.code={
    \pgfscope% scope to contain \tikz@double@setup
      \tikz@double@setup
      % extract double distance between line centers into \pgf@x
      \pgf@nfold@compute@widths@from@double
      % store (order-1)*\pgf@y in \pgf@ya
      \c@pgf@counta=#1
      \advance\c@pgf@counta by -1\relax
      \pgf@ya=\c@pgf@counta\pgf@y
      % compute the label offset, which is (order-2)*\pgf@y + .5*\pgf@x
      \advance\c@pgf@counta by -1\relax
      \pgf@xa=\c@pgf@counta\pgf@y
      \advance\pgf@xa by .5\pgf@x
      % save the results in \pgf@x and \pgf@y
      \global\pgf@x=\pgf@xa
      \global\pgf@y=2\pgf@ya
    \endpgfscope
    \tikzset{
      commutative diagrams/every label/.append style/.expanded={outer sep=\the\pgf@x},
      double distance between line centers=\pgf@y,
      nfold=#1
    }
  },
  commutative diagrams/scaling nfold/.default=2
}

\endinput
